DONE

    Swap out send_mutex for atomic increment

    Verify that the send threads wake up and want to send 50 packets each (100 sent total)

    Make sure we clamp num_packets for XDP, since it will be using atomic increment, it can increment past the max packets sent

    OK we do have a major problem, which is that we don't have an easy way to get back from packet_data to the send queue

    We need the sequence # passed back in to finish packet / abort packet

    Implement finish packet XDP

    Implement abort packet XDP

    We should now see each thread wanting to send 50 packets again

    Instead, they now each want to send 49 packets. Off by one somewhere?

    It's getting complex enough that I think we should have different server implementations

        next_server_portable.cpp
        next_server_linux.cpp

    If the portable server is limited to direct only, it's not going to have too much duplication with the linux server.

    Pass over the portable server and make it lock free with atomics.    

    Pass over the linux server and fix send sequence to be atomic.

TODO

    Debug why we are seeing 49 packets to send, instead of 50.

    What's happening is that some packets come through with a packet_bytes of zero in the send thread.

    But I don't understand how this can happen, unless something is wrong with the double buffer?

    ----------

    Create a separate frame allocator for receive packets vs. send packets.

    The first half of the umem will have frames for packet sends, the second half will be frames for packet receives.

    ----------

    Each socket needs to know the ethernet addresses, and the server ipv4 and port big endian.

    ----------

    Actually hook up the AF_XDP send code

    ----------

    Verify the client receives packets from the server.

    ----------

    Server AF_XDP is basically working at this point!

    ----------

    It's technically possible to avoid the copy by using the umem and allocating frames double buffered in the umem, instead of copying across.

    I should probably do this, especially on send because it does need to be as fast as possible.

    ----------











    -------------

    Implement rate limiting in XDP x requests per-y seconds keyed on IP address

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement ip2location in client backend

    -------------

    Implement the client ping near relay design

    -------------

    Implement requesting a route and sending packets across it

    -------------

    Double this route and implement multipath

    -------------
