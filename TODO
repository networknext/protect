DONE

	When I packets all the same size it works, even if the size is something odd like 99.

	When I send varying packet sizes only a few get through and then it stops.

	I'm not really sure what is causing this? It seems very strange.

	Clue. It *also* breaks in a similar way when sending to multiple client IPs.

	It breaks the same way even if the client is on a linux server, so it's not something wrong with my ISP connection or the Mac dropping packets in some way.

	The NIC definitely thinks it has transferred the packets out and isn't triggering any errors, so it could be something wrong with how the packet is constructed that gets it dropped on the internet.

	But I can't understand how it would only break in this particular way?

	Disabling zero copy on the XDP driver makes no difference. If it was a driver issues, this probably would have fixed it.

	There is no problem with packets not being completed. I don't think the AF_XDP send loop or receive loop are at fault here. Nothing is backing up.

	I am able to send a significant number of packets from 10+ clients, 1000 packets per-second each to the server and it handles them fine.

	The only thing is that occasionally we see this: could not reserve packets in fill queue (0)

	It would be good to solve this problem, so at least we can be confident that the receive packet side is solid.

	Simplest approach to fixing the fill queue stall seems to work. Added a fatal error in case non-zero fail to reserve can happen.

	OK I'm pretty confident I know what's going on. The same frame pointer is being used for multiple packets, thus, when the packets all have the same size, it does send a stream of them, but when teh packets have different sizes, they rarely get through.

	This explains both why the random size packets (mostly) fail, and why it fails similarly when mulitple addresses are added to the mix, again, these packet data is re-used so the packets get all messed up.

	Solution: Verify this is the case by printing out the pointer for the packet data for each packet sent.

	Alternatively, something is messed up with the descriptor causing this to be all jacked up. TBD.

	OK. It's really simple. The send frame allocator is written and read from multiple threads, but it's not protected by a mutex.

	Thus the frames are getting trashed between the two threads...

	Should be able to verify this is the case by putting a simple mutex around the frame allocator.

	No. It is a threading issue, or it is an issue where frames are getting re-used incorrectly

	BUT

	It's not caused by lack of synchronization. Each send queue has its own umem and send/receive allocators, and these allocators and frames are only used by one thread.

	What's going on here is that frames are getting completed and modified, before the driver actually sends the packet.

	I'm certain of it.

	If we could modify the frames so it rotates through them, instead of re-using the same frames over and over, it'd be more resilient.

	Test this theory by not freeing completed send frames.

	If the theory is true, the clients should receive packets again, up till the point where the frames wrap around.

	Yes. Confirmed.	

TODO
	
	Verify multiple clients work fine...

	But after a while, it wraps around, and then it starts fucking up again.

	Is it possible that some fields are not being set properly or need to be cleared? They are uninitialized?

	Maybe clearing the header post write is the correct test for this. Try it...

	It's working fine now, but it's possible that the trigger was trying to connect from the same ethernet address.

	Try disabling the memset 0 and see if the weird hitchy shit comes back by itself.