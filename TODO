DONE

    Now I'm getting weird hung and disconnected when I run the server xdp program?

    I've requested a second IP address for the new york server, so I can load the XDP program on the second NIC (while SSH'ing in on the first NIC)

    They just statically redirected the second IP to the first, doing nothing. So I cancelled the server.

    I will setup my hulk linux machine and work in my lab instead.

    Get hulk up and running so I can send packets with AF_XDP

    Fixed the bug that was breaking the NIC. Bad offset values were crashing out the NIC.

    Now check if we can send a subset of the frames we reserved and not run out of send queue.

    We cannot. At this point I think it's correct to accept that we must reserve and send the number of packets we say.

    This means we need two interfaces, a regular, memcpy once interface for sending packets. Looks just like the non-XDP way.

    And then we have this zero copy interface, where you specifically have to call out the number of packets to send and you *must* send that many packets. 

TODO
















    Implement send with AF_XDP

    First, reserve n packets in the send queue. I believe we don't have to actually transmit all that we reserve.

        int send_index;
        int result = xsk_ring_prod__reserve( &socket->send_queue, SEND_BATCH_SIZE, &send_index );
        if ( result == 0 ) 
        {
            return;
        }

    For each packet sent, allocate a frame in the umem and save the address and length of the packet.

        uint64_t frame = socket_alloc_frame( socket );

    For each packet not aborted (not zero length), fill the tx desc:

        struct xdp_desc * desc = xsk_ring_prod__tx_desc( &socket->send_queue, send_index + i );
        desc->addr = packet_address[i];
        desc->len = packet_length[i];

    Submit the send queue:

        xsk_ring_prod__submit( &socket->send_queue, num_packets );

    Wakeup the driver to do work:

        if ( xsk_ring_prod__needs_wakeup( &socket->send_queue ) )
            sendto( xsk_socket__fd( socket->xsk ), NULL, 0, MSG_DONTWAIT, NULL, 0 );

    Free any aborted frames (immediate).

    Free any completed frames.

        // mark completed sent packet frames as free to be reused

        uint32_t complete_index;

        unsigned int completed = xsk_ring_cons__peek( &socket->complete_queue, XSK_RING_CONS__DEFAULT_NUM_DESCS, &complete_index );

        if ( completed > 0 ) 
        {
            for ( int i = 0; i < completed; i++ )
            {
                socket_free_frame( socket, *xsk_ring_cons__comp_addr( &socket->complete_queue, complete_index++ ) );
            }

            xsk_ring_cons__release( &socket->complete_queue, completed );

            __sync_fetch_and_add( &socket->sent_packets, completed );

            socket->counter += completed;
        }

    This *should* be it!

    The main question is around, how large is the send queue by default, and should I just guess with a large-ish number, or provide the user with the ability to have multiple swings at it, or?

    -------------

    Implement receive with AF_XDP

    -------------

    *** Good stopping point here ***

































    -------------

    Implement rate limiting in XDP x requests per-y seconds keyed on IP address

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement ip2location in client backend

    -------------

    Implement the client ping near relay design

    -------------

    Implement requesting a route and sending packets across it

    -------------

    Double this route and implement multipath

    -------------
