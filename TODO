DONE

    Use the zero copy interface to send packets to all connected clients

    Mock client 0 being connected and verify that we can send packets to it

    Mock client always being at port 30000, verify it receives direct packets sent from the server -> callback

    We're going to need to do client slots on the server

    Separate out client payload sequence from the sequence used for other packet types. Not all packet types need a sequence.

    This lets us send packets to addresses (not client slots...) for internal packets while negotiating connection for example.

    If an IP address is passed in instead of a connect token, just go straight to "CONNECTED" state on the client and send and receive passthrough packets.

    Implement direct mode on client.

    Unify all packet types in next_packets.h

    Handle NEXT_PACKET_DIRECT and pass to user via callback

    Verify client sees 100 byte packets sent to it from server

    Client should receive sequence number when a payload packet comes in

    Implement the client sending direct payload packets to the server

TODO

    Bring across zero copy receive packet functions

    Use the zero copy interface to print logs when the server receives payload packets from clients

    -------------

    There needs to be an actual handshake to pick a client slot (index)

    Start with a version of this using direct packets (debug only)

    -------------

    Extend the server so it uses AF_XDP to send and receive packets on linux

    -------------

    Implement a server XDP program that does the packet filtering and checks for the server before passing down to userspace

    -------------
































    -------------

    Implement endian fix up for packet structs

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement the ping near relays state of client init

    The trick here is that not only do we want the set of relays to ping, we also want...

    1. more relays to ping than can fit in one response packet

    2. an estimate of best cost from each relay to the destination

    This will allows us to quickly stop pinging relays that have demonstrated after 1 second that they are probably not suitable

    Think of it sort of a progressive refinement

    It also will let us in the common case very quickly decide, ok, these relays are fine, let's go.

    -------------
