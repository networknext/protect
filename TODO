DONE

    Sketch out design for one socket and umem per-NIC queue

    And then setup with two NIC queues.

    Manually poll them once per-frame (for now...)

    What's the next step?

    Some options:

        1. Implement packet sending across multiple queues (scatter...)

        2. Copy packets from the receive queue into the receive buffer (seems wrong approach though...)

        3. Move packet receives to multiple threads, and separate out the management of frames for fill/receive vs. send/complete so there is not contention

        4. Move packet sends to multiple threads (but then the question is how to wake up the send packet threads to do work?)

    I think that implementing receive packets across multiple threads, and working out what core to pin those threads to is an important step. 

    What needs to be done to implement receive packets across multiple threads?

    First I think we need a receive buffer per-socket, double buffered with a pointer to the current receive buffer.

    The sync point happens with main thread (receive packets) and the main thread flips that atomic ptr to the other one, and then does the regular receive on the main.

    Start here, it's complex enough to be interesting. It still requires copying (not zero copy), but it's only one copy and receive is not a hot path really.

    Setup the double buffer receive buffer per-socket thing, and then start doing the atomic ptr swap.

    Modify how process packet is done with XDP so the process packets is just ptrs to packets in various socket receive buffers.

    Clean up and start testing the client and server on localhost.

    Debug why the server is sending packet type 0 when it should be sending NEXT_PACKET_DIRECT (6)

    This is causing the client to timeout.

    Was just off by 8 bytes because I forgot to subtract it for the sequence.

    Run the server XDP receive packets on separate threads.

    Next? Run with poll so the receive threads don't take 100% CPU.

    Batch the return received descriptors to fill queue.

    Spin until we return all received frames to the fill queue, otherwise we break (have no choice).

    Add an event fd so we can wakeup the receive thread when it needs to be shut down.

    Change the send sequence number to atomic increment

    Extract the from address and port from the iphdr and udphdr structs

    Create send thread per-xdp socket

    Setup an event_fd so the send threads know to wake up when they have finished work

    Create separate send buffers per-socket

    Make these send buffers double buffered like receive.

    Verify that send threads wake up to do work.

    Needed to read 8 bytes on the event_fd so it keeps working, otherwise one of the threads doesn't wake up.

    Extend so we send multiple packets per-frame.

    Modulo number of queues and distribute packets across different send queues.

    Implement the send buffer queue up for server start packet XDP

TODO

    Swap out send_mutex for atomic increment

    Make sure we clamp num_packets for XDP, since it will be using atomic increment, it can increment past the max packets sent

    ----------

    Verify that packets

    ----------

    Implement abort packet XDP

    Implement finish packet XDP

    Verify that the send threads wake up and want to send n packets

    ----------

    Create a separate frame allocator for receive packets vs. send packets.

    The first half of the umem will have frames for packet sends, the second half will be frames for packet receives.

    ----------

    Bring across as much code as possible to prep-packets and frames for sending, but don't actually send

    ----------

    Each socket needs to know the ethernet addresses, and the server ipv4 and port big endian.

    ----------

    Actually implement the packet send

    ----------

    Verify the client receives packets from the server.

    ----------

    Verify that packets are sent across both send threads.

    ----------

    Server AF_XDP is basically working at this point!













    -------------

    Implement rate limiting in XDP x requests per-y seconds keyed on IP address

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement ip2location in client backend

    -------------

    Implement the client ping near relay design

    -------------

    Implement requesting a route and sending packets across it

    -------------

    Double this route and implement multipath

    -------------
