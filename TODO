DONE

    Switch to packet struct when sending client init request packet

    Remove config. We really don't need it. Client can configure fully with connect token, and the server can just read env vars or do its own config if it needs to.

    Implement the code that fails to connect after the connect timeout is reached

    The connect timeout should be specified in the connect token so the client is zero configuration

    Verify that we can have the client backend shut down, and the client will give up after a while and go to error state

    Extend the connect token so it has the backend token refresh rate in it (30 seconds...)

    Implement the code on the client to request to refresh the backend token

    This will need to include retries (once per-second until we get a response...)

    Implement the backend responding to the refresh backend token request with a new encrypted backend token

    Verify the client gets the refresh token response packet

    Implement the client processing the refresh token response, stashing the updated backend token and setting the next refresh to n seconds in future

    Verify that the client sits and refreshes backend token post-init every 30 seconds

    Implement the client backend state map

    Set the current time in the client backend state map once per-second

    Get the current time in XDP from the state map

    Verify that the client can connect and refresh backend tokens without having them expire for 10 minutes

    Read the client backend private key from env var when the client backend starts up

TODO

    Stick the client backend private key in the client backend config map

    Update the XDP program so it gets client backend public and private keys from the config map

    -------------

    Implement the client backend buyer map

    This map goes from buyer id to data for the buyer

    In the buyer struct, we will have the buyer public key

    Then, we can update the XDP program to get the buyer public key from the buyer map

    -------------

    Generalize everything so it works across big and little endian machines.

    Do it by byte swapping so we don't have to do per-field serialization. Keep it simple.

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    If an IP address is passed in instead of a connect token, just go straight to "CONNECTED" state on the client and send and receive passthrough packets.

    This is the simplest possible way to make it super easy to test during development.

    This payload packet codepath must be disabled in the shipping build, so even if you know the server IP address, you cannot connect to it.

    -------------

    Implement the ping near relays state of client init

    The trick here is that not only do we want the set of relays to ping, we also want, 

    1. more relays to ping than can fit in one response packet

    2. an estimate of best cost from each relay to the destination

    This will allows us to quickly stop pinging relays that have demonstrated after 1 second that they are probably not suitable

    Think of it sort of a progressive refinement

    It also will let us in the common case very quickly decide, ok, these relays are fine, let's go.

    -------------
