DONE

    Set direct timeout to 10 seconds. We'll want the accelerated timeout to be much longer (30-60 seconds...)

    Implement a timeout on the direct client.

    Implement simplest possible direct connection -> client index slot on the server.

    Unify functions on the client when client connects, timeouts etc. so everything goes through one place.

    Implement a timeout on the server for direct connections.

    Client sends n disconnect packets to server when quitting direct.

    Server reads disconnect packets and disconnects client clean when it quits.

    SSH back into the linux box

    Implement the server XDP program skeleton

    This program should look at any UDP ports at 1024 and above and pass down to userspace only if they pass the packet filter

    Setup the skeleton for AF_XDP in next_server.cpp #ifdef __linux__

    Added generate packet header function

    Sketch out data structures needed by AF_XDP for building packet header

    Keep an array of the client_address_big_endian and client_port_big_endian so we can pass in to the packet header as-is.

    Stash the server_address_big_endian and server_port_big_endian so we can pass it in to the packet header as-is.

    Look up the server ethernet address and save it to a variable

    First look up the gateway IP address for the network interface by name:

        ubuntu@latitude:~/protect$ netstat -rn | grep UG
        
        0.0.0.0         45.250.253.242  0.0.0.0         UG        0 0          0 eno1

    Then once we have the IP address for the gateway, we can search lines in "arp -a" and look for:

        ubuntu@latitude:~/protect$ arp -a
        
        ? (45.250.253.242) at 50:87:89:d4:37:2d [ether] on eno1

    This way we should be able to always get the correct gateway ethernet address for outgoing packets.

    ps. We assume that XDP servers will *never* be doing any direct communication within a local network.

    Actually, ended up using "ip neigh show" instead of "arp -a" because the latter takes several seconds and ip is instant.

    Bring across frame allocator protected by a mutex

    Restructure packet send and receive so they have begin/end -- this will help with XDP.

TODO

    Implement send with AF_XDP

    First, reserve n packets in the send queue. I believe we don't have to actually transmit all that we reserve.

        int send_index;
        int result = xsk_ring_prod__reserve( &socket->send_queue, SEND_BATCH_SIZE, &send_index );
        if ( result == 0 ) 
        {
            return;
        }

    For each packet sent, allocate a frame in the umem and save the address and length of the packet.

        uint64_t frame = socket_alloc_frame( socket );

    For each packet not aborted (not zero length), fill the tx desc:

        struct xdp_desc * desc = xsk_ring_prod__tx_desc( &socket->send_queue, send_index + i );
        desc->addr = packet_address[i];
        desc->len = packet_length[i];

    Submit the send queue:

        xsk_ring_prod__submit( &socket->send_queue, num_packets );

    Wakeup the driver to do work:

        if ( xsk_ring_prod__needs_wakeup( &socket->send_queue ) )
            sendto( xsk_socket__fd( socket->xsk ), NULL, 0, MSG_DONTWAIT, NULL, 0 );

    Free any aborted frames (immediate).

    Free any completed frames.

        // mark completed sent packet frames as free to be reused

        uint32_t complete_index;

        unsigned int completed = xsk_ring_cons__peek( &socket->complete_queue, XSK_RING_CONS__DEFAULT_NUM_DESCS, &complete_index );

        if ( completed > 0 ) 
        {
            for ( int i = 0; i < completed; i++ )
            {
                socket_free_frame( socket, *xsk_ring_cons__comp_addr( &socket->complete_queue, complete_index++ ) );
            }

            xsk_ring_cons__release( &socket->complete_queue, completed );

            __sync_fetch_and_add( &socket->sent_packets, completed );

            socket->counter += completed;
        }

    This *should* be it!

    The main question is around, how large is the send queue by default, and should I just guess with a large-ish number, or provide the user with the ability to have multiple swings at it, or?

    -------------

    Implement receive with AF_XDP

    -------------

    *** Good stopping point here ***

































    -------------

    Implement rate limiting in XDP x requests per-y seconds keyed on IP address

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement ip2location in client backend

    -------------

    Implement the client ping near relay design

    -------------

    Implement requesting a route and sending packets across it

    -------------

    Double this route and implement multipath

    -------------
