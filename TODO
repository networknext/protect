DONE

    Switch over to libhydrogen in the SDK

    Verify that I can build hydrogen.c in the kernel module and it links and loads

    Setup a test linux server with 10G NIC with latitude.sh

    Verify that I get reflected UDP packets back from the client backend running on latitude.sh

    Update the write_connect_token and read_connect_token so they work with libhydrogen

    Generate a new keypair with hydrogen, because it's not compatible with sodium keypairs
    
    Setup to unit test again

    Add a unit test for connect token. Lock it in.

    Bring back other unit tests that are not related to client/server.

    Move CMake shit into "build" dir because it's terrible

    Work out required crypto steps for client backend token

    It's simple, it's symmetric encryption, so we just have a private key for the client backend

        #define hydro_secretbox_CONTEXTBYTES 8
        #define hydro_secretbox_HEADERBYTES  (20 + 16)
        #define hydro_secretbox_KEYBYTES     32
 
        void hydro_secretbox_keygen(uint8_t key[hydro_secretbox_KEYBYTES]);

        int hydro_secretbox_encrypt(uint8_t *c, const void *m_, size_t mlen, uint64_t msg_id,
                                    const char    ctx[hydro_secretbox_CONTEXTBYTES],
                                    const uint8_t key[hydro_secretbox_KEYBYTES]);

        int hydro_secretbox_decrypt(void *m_, const uint8_t *c, size_t clen, uint64_t msg_id,
                                    const char    ctx[hydro_secretbox_CONTEXTBYTES],
                                    const uint8_t key[hydro_secretbox_KEYBYTES])

    Need to work out what hydro_secretbox_CONTEXTBYTES and hydro_secretbox_HEADERBYTES are for

        // 1. Generate a secret key
        uint8_t key[hydro_secretbox_KEYBYTES];
        hydro_secretbox_keygen(key);

         // 2. Define message, context, and message ID
        const char *message = "This is a secret message.";
        size_t message_len = strlen(message);
        const char context[hydro_secretbox_CONTEXTBYTES] = "my_app_ctx";
        uint64_t msg_id = 12345; // Optional message identifier

        // 3. Prepare buffer for ciphertext
        // Ciphertext length = HEADERBYTES + message_len
        uint8_t ciphertext[hydro_secretbox_HEADERBYTES + message_len];

        // 4. Encrypt the message
        int encrypt_result = hydro_secretbox_encrypt(
            ciphertext,
            (const void *)message,
            message_len,
            msg_id,
            context,
            key
        );

    But aside from this, it looks like a pretty standard encryption/decryption

    msg_id is optional and we can just omit it

    nonce is automatically generated (random) and is secure. it's included in the header part.

TODO

    Define the client backend token including crypto parts

    -------------

    Implement next_write_client_backend_token

    Implement next_read_client_backend_token

    Unit test client backend token

    -------------

    Define the client init request and response packets (keep them simple for XDP)

    -------------

    Implement the client sending the client init request packet to n backends until it receives m responses from a backend and picks that client backend.

    -------------

    Implement client backend XDP program verifying client init request packet using hydrogen, and responding with a client backend token (symmetric encrypted).

    -------------

    Generalize connect token and client backend token so they know to do the bswap fixup for big endian machines

    -------------
