DONE

    Sketch out design for one socket and umem per-NIC queue

    And then setup with two NIC queues.

    Manually poll them once per-frame (for now...)

    What's the next step?

    Some options:

        1. Implement packet sending across multiple queues (scatter...)

        2. Copy packets from the receive queue into the receive buffer (seems wrong approach though...)

        3. Move packet receives to multiple threads, and separate out the management of frames for fill/receive vs. send/complete so there is not contention

        4. Move packet sends to multiple threads (but then the question is how to wake up the send packet threads to do work?)

    I think that implementing receive packets across multiple threads, and working out what core to pin those threads to is an important step. 

    What needs to be done to implement receive packets across multiple threads?

    First I think we need a receive buffer per-socket, double buffered with a pointer to the current receive buffer.

    The sync point happens with main thread (receive packets) and the main thread flips that atomic ptr to the other one, and then does the regular receive on the main.

    Start here, it's complex enough to be interesting. It still requires copying (not zero copy), but it's only one copy and receive is not a hot path really.

    Setup the double buffer receive buffer per-socket thing, and then start doing the atomic ptr swap.

    Modify how process packet is done with XDP so the process packets is just ptrs to packets in various socket receive buffers.

    Clean up and start testing the client and server on localhost.

    Debug why the server is sending packet type 0 when it should be sending NEXT_PACKET_DIRECT (6)

    This is causing the client to timeout.

    Was just off by 8 bytes because I forgot to subtract it for the sequence.

    Run the server XDP receive packets on separate threads.

    Next? Run with poll so the receive threads don't take 100% CPU.

TODO

    Batch the return received descriptors to fill queue.

    ----------

    Create a separate frame allocator for receive packets vs. send packets, this way they can be on different threads.

    ----------

    Create separate send buffers per-socket

    Make these send buffers double buffered like receive.

    This way we can distribute packets sent across multiple thread send queues without mutexes per-packet send

    ----------

    Also change the send sequence number to atomic increment

    ----------

    Move the send packets onto its own thread. Ask the question how can we wake up when there are packets to be sent, but not do work when there is not?

    Design the send packets thread operation.
















    -------------

    Implement rate limiting in XDP x requests per-y seconds keyed on IP address

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement ip2location in client backend

    -------------

    Implement the client ping near relay design

    -------------

    Implement requesting a route and sending packets across it

    -------------

    Double this route and implement multipath

    -------------
